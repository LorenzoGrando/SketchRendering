#pragma kernel ComputeAverageStroke32
#pragma kernel ComputeAverageStroke16
#pragma kernel ComputeAverageStroke8
#pragma kernel ComputeAverageStroke4
#pragma kernel ApplyStrokes32
#pragma kernel ApplyStrokes16
#pragma kernel ApplyStrokes8
#pragma kernel ApplyStrokes4

#pragma multi_compile_local _ USE_PERPENDICULAR_DIRECTION

#include "Assets/Scripts/TAMGenerator/StrokeSDFInclude.hlsl"

#define PI 3.14159265358979323846;

RWStructuredBuffer<float4> _GradientVectors;
RWTexture2D<float4> _OriginalSource;
uint _GroupsX;
uint _GroupsY;
uint _TextureWidth;
uint _TextureHeight;
float _ThresholdForStroke;

//declare them at max supported kernel size, though this does lead to some wasted memory
groupshared float4 gradients[32*32];
groupshared float localIsEdge[32*32];
void ComputeAverageStroke (uint3 id, uint3 idG, uint3 idGs, uint2 kernelSizes)
{
    uint gFlatIndex = idG.y * kernelSizes.x + idG.x;
    uint groupFlatIndex = idGs.y * _GroupsX + idGs.x;
    int totalElements = (int)(kernelSizes.x * kernelSizes.y);

    float angle = _OriginalSource[id.xy].g;
    angle = angle * 2.0 * PI - PI;
    
    float isEdge = _OriginalSource[id.xy].r;
    float2 position = float2(id.x/(float)_TextureWidth, id.y/(float)_TextureHeight);
    float2 direction = float2(cos(angle), sin(angle));
    float4 gradient = float4(position.xy, direction.xy);
    gradients[gFlatIndex] = gradient;
    localIsEdge[gFlatIndex] = step(0.5, isEdge);
    GroupMemoryBarrierWithGroupSync();
    
    if (idG.x == 0 && idG.y == 0)
    {
        float2 averagePosition = float2(0, 0);
        float2 averageDirection = float2(0, 0);
        int summed = 0;
        [loop]
        for (int i = 0; i < totalElements; i++)
        {
            if (localIsEdge[i] > 0)
            {
                averagePosition += gradients[i].rg;
                averageDirection += gradients[i].ba;
                summed++;
            }
        }
        float isAverageStroke = step(_ThresholdForStroke, summed/(float)(totalElements));
        if(isAverageStroke)
        {
            averagePosition /= (float)summed;
            averageDirection /= (float)summed;
            #if defined (USE_PERPENDICULAR_DIRECTION)
            averageDirection = float4(cross(float3(averageDirection.xy, 0), float3(0, 0, 1)).xy, 0, 0);
            #endif
        }
        gradients[0] = float4(averagePosition, averageDirection * isAverageStroke);
        _GradientVectors[groupFlatIndex] = gradients[0];
    }
    GroupMemoryBarrierWithGroupSync();

    //Debugging
    float4 grad = gradients[0];
    _OriginalSource[id.xy] = float4(abs(grad.ba), 0.0, 1.0);
    //float x = float(idG.x)/(float)kernelSizes.x;
    //float y = float(idG.y)/(float)kernelSizes.y;
    //_OriginalSource[id.xy] = float4(x, y, 0.0, 1.0);
    //if (idGs.x == 0 && idGs.y == 0)
    //{
    //    _OriginalSource[id.xy] = float4(1.0, 1.0, 1.0, 1.0);
    //}
}


[numthreads(32, 32, 1)]
void ComputeAverageStroke32 (uint3 id : SV_DispatchThreadID, uint3 idG : SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ComputeAverageStroke(id, idG, idGs, uint2(32, 32));
}

[numthreads(16, 16, 1)]
void ComputeAverageStroke16 (uint3 id : SV_DispatchThreadID, uint3 idG : SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ComputeAverageStroke(id, idG, idGs, uint2(16, 16));
}

[numthreads(8, 8, 1)]
void ComputeAverageStroke8 (uint3 id : SV_DispatchThreadID, uint3 idG : SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ComputeAverageStroke(id, idG, idGs, uint2(8, 8));
}

[numthreads(4, 4, 1)]
void ComputeAverageStroke4 (uint3 id : SV_DispatchThreadID, uint3 idG : SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ComputeAverageStroke(id, idG, idGs, uint2(4, 4));
}


RWStructuredBuffer<StrokeData> OutlineStrokeData;
groupshared StrokeData groupData;
groupshared float isEdge;
void ApplyStrokeSDFs(uint3 id, uint2 idG, uint3 idGs, uint2 kernelSizes)
{
    float value = 1;
    float widthScalar = (float)_TextureWidth/(float)kernelSizes.x;
    float heightScalar = (float)_TextureHeight/(float)kernelSizes.y;
    float scalar = min(widthScalar, heightScalar) * 0.5;
    StrokeData data = OutlineStrokeData[0];
    [unroll(3)]
    for (int x = -1; x < 2; x++)
    {
        [unroll(3)]
        for (int  y = -1; y < 2; y++)
        {
            uint xClamp = clamp(idGs.x + (uint)x, 0, _GroupsX - 1);
            uint yClamp = clamp(idGs.y + (uint)y, 0, _GroupsY - 1);
            uint groupFlatIndex = yClamp * _GroupsX + xClamp;
    
            if(idG.x == 0 && idG.y == 0)
            {
                float4 edgeData = _GradientVectors[groupFlatIndex];
                isEdge = step(0.5, length(float2(edgeData.ba)));
                data.coords = float4(edgeData.rg, 0, 0);
                data.direction = float4(edgeData.ba, 0, 0);
                groupData = data;
            }
            GroupMemoryBarrierWithGroupSync();

            if (isEdge)
            {
                float localValue = (float)SampleBaseSDFClampParamScalar(groupData, id.xy, float2(_TextureWidth, _TextureHeight), scalar)/255.0;
                value *= localValue;
            }
        }
    }
    value = 1 - value;
    _OriginalSource[id.xy] = float4(value.rrrr);
    //float u = float(idG.x)/(float)kernelSizes.x * (1- value);
    //float v = float(idG.y)/(float)kernelSizes.y * (1- value);
    //_OriginalSource[id.xy] = float4(u, v, 0.0, 1.0);
    //if (idGs.x == 0 && idGs.y == 0)
    //{
    //    _OriginalSource[id.xy] = float4(1.0, 1.0, 1.0, 1.0);
    //}
}

[numthreads(32,32,1)]
void ApplyStrokes32(uint3 id : SV_DispatchThreadID, uint2 idG: SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ApplyStrokeSDFs(id, idG, idGs, uint2(32, 32));
}

[numthreads(16,16,1)]
void ApplyStrokes16(uint3 id : SV_DispatchThreadID, uint2 idG: SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ApplyStrokeSDFs(id, idG, idGs, uint2(16, 16));
}

[numthreads(8,8,1)]
void ApplyStrokes8(uint3 id : SV_DispatchThreadID, uint2 idG: SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ApplyStrokeSDFs(id, idG, idGs, uint2(8, 8));
}

[numthreads(4,4,1)]
void ApplyStrokes4(uint3 id : SV_DispatchThreadID, uint2 idG: SV_GroupThreadID, uint3 idGs : SV_GroupID)
{
    ApplyStrokeSDFs(id, idG, idGs, uint2(4, 4));
}



